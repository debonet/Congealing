#ifndef __LIBUTILITY_H__
#define __LIBUTILITY_H__

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#ifdef _WIN32
#  include <winsock.h>
#else
#  include <sys/time.h>
#endif

#include "Promotion.h"

//==========================================================================
//==========================================================================
#define CONGEAL_ERROR(s,...) {UD("ERROR:" s ,##__VA_ARGS__); exit(1);}

//==========================================================================
//==========================================================================
#define CONGEAL_WARNING(s,...) {printf("WARNING: "); printf(s ,##__VA_ARGS__); printf("\n");}

//==========================================================================
//==========================================================================
#define CONGEAL_WARNIF(b,s,...) do {if(b){WARNING(s ,##__VA_ARGS__);}} while(0)

//==========================================================================
//==========================================================================
#define CONGEAL_ASSERT(__b) {if (!(__b)) {UD("ASSERT FAILED: %s", #__b); abort();}}

//==========================================================================
//==========================================================================
#define CONGEAL_ASSERTf(__b,s,...) {if (!(__b)) {UD("ASSERT FAILED: %s", #__b); UD(s,##__VA_ARGS__); abort();}}

//==========================================================================
//==========================================================================
#define HERE UD("HERE");

//==========================================================================
//==========================================================================
// print
#define P(_s,...) {printf(_s ,##__VA_ARGS__);printf("\n");}

//==========================================================================
//==========================================================================
// print with no newline
#define PX(_s,...) {printf(_s ,##__VA_ARGS__);}

//==========================================================================
//==========================================================================
// indented print
#define IP(_c,_s,...) {IPX(_c,_s,##__VA_ARGS__); printf("\n");}

//==========================================================================
//==========================================================================
// indented print with no newline
#define IPX(_c,_s,...) {												\
		for (int _n=0; _n<_c; _n++){								\
			printf("\t");															\
		};																					\
		printf(_s,##__VA_ARGS__);										\
}



//==========================================================================
//==========================================================================
#define Stringify2(x,...) #x
#define Stringify(x,...) Stringify2(x,##__VA_ARGS__)

//==========================================================================
//==========================================================================
template <class T>
inline bool IsIntegral(const T& t){
	return t==int(t);
}

/*
//==========================================================================
//==========================================================================
template <class T>
inline T sqr(const T& t){
	return t*t;
}
*/

//============================================================================
//============================================================================
template <class PRECISION> 
RANGEPROMOTION(PRECISION) sqr(const PRECISION& r){
	return r*r;
}

//==========================================================================
//==========================================================================
template <class T>
inline int sign(const T& t){
	return t<0?-1:1;
}

//==========================================================================
//==========================================================================
template <class T1, class T2>
inline const PROMOTION(T1,T2)& congeal_max(const T1& t1, const T2& t2){
	return (t1>t2)?t1:t2;
}

//==========================================================================
//==========================================================================
template <class T1, class T2>
inline const PROMOTION(T1,T2)& congeal_min(const T1& t1, const T2& t2){
	return (t1<t2)?t1:t2;
}


//==========================================================================
//==========================================================================
template <class T>
inline const T& Bound(const T& t, const T& tMin, const T& tMax){
	return congeal_min(tMax,congeal_max(tMin,t));
}

//==========================================================================
//==========================================================================
template <class T>
inline T Random(const T& tMin, const T& tMax){
	T d=tMax-tMin;
	return T(Modulo(rand()%1000000,d*1000)/1000 + tMin);
}

//==========================================================================
//==========================================================================
template <class T>
inline void Swap(T& t1,  T& t2){
	T tT=t1;
	t1=t2;
	t2=tT;
}

//==========================================================================
//==========================================================================
template <class T1, class T2>
PROMOTION(T1,T2) Modulo(T1 t, T2 tBase){
	int cRem=int(t/tBase);
	return t-cRem*tBase;
}

//==========================================================================
//==========================================================================
template <class T1, class T2>
PROMOTION(T1,T2) AbsModulo(T1 t, T2 tBase){
	PROMOTION(T1,T2) tMod=Modulo(t,tBase);
	return tMod<0?tMod+tBase:tMod;
}



//==========================================================================
//==========================================================================
inline double timestamp()
{
	struct timeval tv;
	gettimeofday(&tv, NULL);
	return tv.tv_sec+double(tv.tv_usec)/1000000;
}

//==========================================================================
//==========================================================================
#define DTIMEEXECUTION(_s,_code) {																						\
		TIMEEXECUTION(_timer,_code);																							\
		D(_s,_timer);																															\
	}

//==========================================================================
#define UDTIMEEXECUTION(_s,_code) {																						\
		TIMEEXECUTION(_timer,_code);																							\
		UD(_s,_timer);																															\
	}

//==========================================================================
//==========================================================================
#define DTIMELOOPEXECUTION(_s,_c,_code) {																			\
		TIMEEXECUTION(_timer,for (int _n=0; _n<_c; _n++){_code;});								\
		D(_s,_timer);																															\
	}

//==========================================================================
//==========================================================================
#define TICK(_timer)																													\
	double _timer = timestamp();

//==========================================================================
//==========================================================================
#define TOCK(_timer)																													\
	(timestamp() - _timer )		

//==========================================================================
//==========================================================================
#define DTOCK(_s,_timer)												\
	D(_s,TOCK( _timer ) )

//==========================================================================
//==========================================================================
#define UDTOCK(_s,_timer)												\
	UD(_s,TOCK( _timer ) )

//==========================================================================
//==========================================================================
template <class T>
void SafeDelete(T*& pt){
	if (pt!=NULL){
		delete pt;
	}
}
//==========================================================================
//==========================================================================
template <class T>
void SafeDeleteArray(T*& pt){
	if (pt!=NULL){
		delete [] pt;
	}
}



#undef DEBUG 
#define DEBUG 9
#include "libDebug.h"

#endif //#ifndef __LIBUTILITY_H__
